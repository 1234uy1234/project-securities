import React, { useState, useRef, useCallback, useEffect } from 'react';
import { X, Camera, AlertCircle, CheckCircle, Loader } from 'lucide-react';
import cameraManager, { CAMERA_TYPES, CAMERA_CONSTRAINTS } from '../utils/cameraManager';

interface SimpleFaceAuthModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSuccess: (userData: any) => void;
  mode: 'register' | 'verify';
  username?: string; // Username ƒë·ªÉ l∆∞u ·∫£nh (ch·ªâ c·∫ßn cho register)
  onRegisterSuccess?: () => void;
}

const SimpleFaceAuthModal: React.FC<SimpleFaceAuthModalProps> = ({
  isOpen,
  onClose,
  onSuccess,
  mode,
  username,
  onRegisterSuccess
}) => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [stream, setStream] = useState<MediaStream | null>(null);
  const [isCapturing, setIsCapturing] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  const startCamera = useCallback(async () => {
    try {
      setError(null);
      console.log('üé• Starting camera...');
      
      // S·ª≠ d·ª•ng camera tr·ª±c ti·∫øp thay v√¨ cameraManager
      const mediaStream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 640, min: 320, max: 1280 },
          height: { ideal: 480, min: 240, max: 720 },
          facingMode: 'user',
          frameRate: { ideal: 15, min: 10, max: 30 }
        }
      });
      
      setStream(mediaStream);
      
      if (videoRef.current) {
        videoRef.current.srcObject = mediaStream;
        
        // ƒê·ª£i video load xong
        videoRef.current.onloadedmetadata = () => {
          if (videoRef.current) {
            videoRef.current.play().then(() => {
              console.log('‚úÖ Camera started successfully');
            }).catch((playError) => {
              console.error('‚ùå Video play error:', playError);
              setError('L·ªói ph√°t video. Vui l√≤ng th·ª≠ l·∫°i.');
            });
          }
        };
        
        videoRef.current.onerror = (e) => {
          console.error('‚ùå Video error:', e);
          setError('L·ªói hi·ªÉn th·ªã video. Vui l√≤ng th·ª≠ l·∫°i.');
        };
      }
    } catch (err: any) {
      console.error('‚ùå Camera error:', err);
      let errorMessage = 'Kh√¥ng th·ªÉ truy c·∫≠p camera';
      
      if (err.name === 'NotAllowedError') {
        errorMessage = 'B·∫°n c·∫ßn c·∫•p quy·ªÅn truy c·∫≠p camera';
      } else if (err.name === 'NotFoundError') {
        errorMessage = 'Kh√¥ng t√¨m th·∫•y camera';
      } else if (err.name === 'NotReadableError') {
        errorMessage = 'Camera ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi ·ª©ng d·ª•ng kh√°c';
      }
      
      setError(errorMessage);
    }
  }, []);

  const stopCamera = useCallback(async () => {
    console.log('üõë Stopping camera...');
    
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
      setStream(null);
    }
    
    if (videoRef.current) {
      videoRef.current.srcObject = null;
    }
  }, [stream]);

  useEffect(() => {
    if (isOpen) {
      startCamera();
    } else {
      stopCamera();
    }
    
    return () => {
      stopCamera();
    };
  }, [isOpen]); // Ch·ªâ depend v√†o isOpen, kh√¥ng depend v√†o startCamera/stopCamera

  const capturePhoto = useCallback(() => {
    if (!videoRef.current || !canvasRef.current || isCapturing) {
      console.log('‚ùå Cannot capture: missing refs or already capturing');
      return null;
    }
    
    setIsCapturing(true);
    setError(null);
    
    try {
      const video = videoRef.current;
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      
      if (!ctx) {
        throw new Error('Kh√¥ng th·ªÉ l·∫•y canvas context');
      }
      
      // Ki·ªÉm tra video ƒë√£ s·∫µn s√†ng ch∆∞a
      if (video.videoWidth === 0 || video.videoHeight === 0) {
        throw new Error('Video ch∆∞a s·∫µn s√†ng - k√≠ch th∆∞·ªõc: ' + video.videoWidth + 'x' + video.videoHeight);
      }
      
      // Set canvas size
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      // Draw video frame to canvas
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      // Convert to base64
      const base64 = canvas.toDataURL('image/jpeg', 0.9);
      
      // Validate base64 data
      if (!base64 || base64.length < 1000) {
        throw new Error('D·ªØ li·ªáu ·∫£nh kh√¥ng h·ª£p l·ªá - ƒë·ªô d√†i: ' + base64.length);
      }
      
      console.log('üì∏ Photo captured successfully');
      console.log(`üìè Canvas size: ${canvas.width} x ${canvas.height}`);
      console.log(`üì¶ Image size: ${base64.length} characters`);
      console.log(`üìä Base64 preview: ${base64.substring(0, 50)}...`);
      
      setIsCapturing(false);
      return base64;
    } catch (error) {
      console.error('‚ùå Error capturing photo:', error);
      setError('L·ªói ch·ª•p ·∫£nh: ' + (error as Error).message);
      setIsCapturing(false);
      return null;
    }
  }, [isCapturing]);

  const processFaceAuth = async (imageData: string) => {
    setIsProcessing(true);
    setError(null);
    setSuccess(null);

    try {
      console.log('üîç Processing face auth...');
      console.log(`üì¶ Image size: ${imageData.length} characters`);
      
      // Validate image data
      if (!imageData || !imageData.startsWith('data:image/')) {
        throw new Error('D·ªØ li·ªáu ·∫£nh kh√¥ng h·ª£p l·ªá');
      }
      
      const base64Data = imageData.split(',')[1];
      if (!base64Data || base64Data.length < 1000) {
        console.error('‚ùå Invalid image data:');
        console.error('  - imageData length:', imageData.length);
        console.error('  - base64Data length:', base64Data ? base64Data.length : 'null');
        console.error('  - imageData preview:', imageData.substring(0, 100));
        throw new Error('·∫¢nh qu√° nh·ªè ho·∫∑c kh√¥ng c√≥ d·ªØ li·ªáu');
      }
      
      console.log(`üìä Base64 data length: ${base64Data.length}`);
      console.log(`üìä Image format: ${imageData.split(',')[0]}`);
      console.log(`üìä Full imageData length: ${imageData.length}`);
      
      let endpoint;
      let formData = new FormData();
      
      if (mode === 'register') {
        if (!username) {
          throw new Error('Username is required for registration');
        }
        endpoint = 'https://10.10.68.72:8000/api/face-storage/save-face';
        formData.append('image_data', imageData);
        formData.append('username', username);
        console.log(`üìù Registering face for user: ${username}`);
      } else {
        endpoint = 'https://10.10.68.72:8000/api/face-storage/compare-face';
        formData.append('image_data', imageData);
        console.log('üîç Comparing face with database');
      }
      
      console.log(`üåê Sending request to: ${endpoint}`);
      
      // S·ª≠ d·ª•ng axios thay v√¨ fetch ƒë·ªÉ tr√°nh CORS
      const { api } = await import('../utils/api');
      const response = await api.post(endpoint.replace('https://10.10.68.72:8000/api', ''), formData)
      
      const result = response.data;
      console.log('üì° Response:', result);
      
      if (result.success) {
        setSuccess(result.message);
        
        if (mode === 'register') {
          console.log('‚úÖ Face registration successful');
          onRegisterSuccess?.();
          setTimeout(() => {
            onClose();
          }, 2000);
        } else {
          console.log('‚úÖ Face verification successful');
          if (result.matched_user) {
            // L∆∞u token v√† user data
            if (result.access_token) {
              localStorage.setItem('access_token', result.access_token);
              localStorage.setItem('token_type', result.token_type || 'bearer');
              
              // L∆∞u v√†o auth-storage
              const authState = {
                user: result.matched_user,
                token: result.access_token,
                isAuthenticated: true
              };
              localStorage.setItem('auth-storage', JSON.stringify(authState));
              
              console.log('üîê Token saved:', result.access_token.substring(0, 20) + '...');
            }
            
            onSuccess(result.matched_user);
            onClose();
          }
        }
      } else {
        setError(result.message || 'C√≥ l·ªói x·∫£y ra');
      }
    } catch (err: any) {
      console.error('‚ùå Face auth error:', err);
      setError('L·ªói k·∫øt n·ªëi: ' + err.message);
    } finally {
      setIsProcessing(false);
    }
  };

  const handleCapture = useCallback(() => {
    if (isCapturing || isProcessing) return;
    
    const imageData = capturePhoto();
    if (imageData && imageData.length > 1000) {
      console.log('‚úÖ Valid image data captured, processing...');
      processFaceAuth(imageData);
    } else {
      console.error('‚ùå Invalid image data:', imageData ? `Length: ${imageData.length}` : 'null');
      setError('Kh√¥ng th·ªÉ ch·ª•p ·∫£nh. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  }, [isCapturing, isProcessing, capturePhoto]);

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg max-w-md w-full max-h-[90vh] overflow-y-auto">
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b">
          <h3 className="text-lg font-semibold text-gray-900">
            {mode === 'register' ? 'ƒêƒÉng k√Ω khu√¥n m·∫∑t' : 'X√°c th·ª±c khu√¥n m·∫∑t'}
          </h3>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        {/* Content */}
        <div className="p-4 space-y-4">
          {/* Camera */}
          <div className="relative bg-black rounded-lg overflow-hidden">
            <video
              ref={videoRef}
              autoPlay
              playsInline
              muted
              className="w-full h-64 object-cover"
            />
            <canvas
              ref={canvasRef}
              className="hidden"
            />
            
            {!stream && (
              <div className="absolute inset-0 flex items-center justify-center bg-gray-800">
                <div className="text-center text-white">
                  <Camera className="w-12 h-12 mx-auto mb-2 opacity-50" />
                  <p className="text-sm">ƒêang kh·ªüi ƒë·ªông camera...</p>
                </div>
              </div>
            )}
          </div>

          {/* Instructions */}
          <div className="text-center">
            <p className="text-sm text-gray-600 mb-2">
              {mode === 'register' 
                ? `ƒêƒÉng k√Ω khu√¥n m·∫∑t cho user: ${username}`
                : 'Nh√¨n v√†o camera v√† nh·∫•n ch·ª•p ·∫£nh ƒë·ªÉ x√°c th·ª±c'
              }
            </p>
            <p className="text-xs text-gray-500">
              ƒê·∫£m b·∫£o √°nh s√°ng ƒë·ªß v√† nh√¨n th·∫≥ng v√†o camera
            </p>
          </div>

          {/* Status Messages */}
          {error && (
            <div className="flex items-center space-x-2 p-3 bg-red-50 border border-red-200 rounded-lg">
              <AlertCircle className="w-5 h-5 text-red-500 flex-shrink-0" />
              <p className="text-sm text-red-700">{error}</p>
            </div>
          )}

          {success && (
            <div className="flex items-center space-x-2 p-3 bg-green-50 border border-green-200 rounded-lg">
              <CheckCircle className="w-5 h-5 text-green-500 flex-shrink-0" />
              <p className="text-sm text-green-700">{success}</p>
            </div>
          )}

          {/* Actions */}
          <div className="flex space-x-3">
            <button
              onClick={handleCapture}
              disabled={!stream || isCapturing || isProcessing}
              className="flex-1 flex items-center justify-center space-x-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isProcessing ? (
                <Loader className="w-4 h-4 animate-spin" />
              ) : (
                <Camera className="w-4 h-4" />
              )}
              <span>
                {isProcessing 
                  ? (mode === 'register' ? 'ƒêang ƒëƒÉng k√Ω...' : 'ƒêang x√°c th·ª±c...')
                  : 'Ch·ª•p ·∫£nh'
                }
              </span>
            </button>
            
            <button
              onClick={onClose}
              className="px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
            >
              H·ªßy
            </button>
          </div>

          {/* Tips */}
          <div className="bg-gray-50 p-3 rounded-lg">
            <h4 className="text-sm font-medium text-gray-900 mb-2">M·∫πo:</h4>
            <ul className="text-xs text-gray-600 space-y-1">
              <li>‚Ä¢ ƒê·∫£m b·∫£o √°nh s√°ng ƒë·ªß</li>
              <li>‚Ä¢ Nh√¨n th·∫≥ng v√†o camera</li>
              <li>‚Ä¢ Gi·ªØ khu√¥n m·∫∑t trong khung</li>
              <li>‚Ä¢ Tr√°nh ƒëeo k√≠nh r√¢m ho·∫∑c kh·∫©u trang</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  );
};

export default SimpleFaceAuthModal;
